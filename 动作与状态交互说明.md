# 动作与状态交互说明

## 一、状态是怎么传送的（AFSIM → Python）

### 1.1 AFSIM 端：收集平台状态

**位置**：`state_observer.txt` 脚本，每 0.5 秒执行一次

```cpp
// 遍历所有平台（18个：红方0-8，蓝方9-17）
for(int i = 0; i < platform_names.Size(); i++) {
    WsfPlatform platform = WsfSimulation.FindPlatform(platform_names.Get(i));
    
    if(platform != null) {
        // 读取平台状态，写入 SACProcessor
        sacprocessor.SetLive(i, 1);                    // 是否存活
        sacprocessor.SetLat(i, platform.Latitude());   // 纬度
        sacprocessor.SetLon(i, platform.Longitude());  // 经度
        sacprocessor.SetAlt(i, platform.Altitude());   // 高度
        sacprocessor.SetVelx(i, platform.VelocityNED().X());  // 速度X
        sacprocessor.SetVely(i, platform.VelocityNED().Y());  // 速度Y
        sacprocessor.SetVelz(i, platform.VelocityNED().Z());  // 速度Z
        sacprocessor.SetHeading(i, platform.Heading());      // 航向角
    } else {
        sacprocessor.SetLive(i, 0);  // 平台不存在，标记为死亡
    }
}

// 设置标志位，通知 C++ 端发送数据
sacprocessor.SetFlag(1);
```

**每个平台的状态数据**（8 个值）：
1. `live` - 是否存活（0 或 1）
2. `lat` - 纬度
3. `lon` - 经度
4. `alt` - 高度（米）
5. `velx` - X 方向速度（米/秒）
6. `vely` - Y 方向速度（米/秒）
7. `velz` - Z 方向速度（米/秒）
8. `heading` - 航向角（度）

### 1.2 AFSIM 端：C++ 发送状态数据

**位置**：`WsfStandardApplication.cpp` 的 `RunEventLoop()` 方法

```cpp
// 在仿真循环中检查 flag
if (sac_processor->flag == 1) {
    // 构建状态字符串
    std::stringstream ss;
    ss << simTime << ' ' << 640 << ' ';  // 仿真时间 + 数据长度（80平台×8值=640）
    
    // 遍历所有平台的状态数组
    for (int i = 0; i < 80; i++) {
        for (int j = 0; j < 8; j++) {
            ss << sac_processor->states[i][j] << ' ';  // 每个值用空格分隔
        }
    }
    
    // 通过 Socket 发送文本数据
    std::string temp = ss.str();
    aSocket->Send(temp.c_str(), strlen(temp.c_str()), 0.1);
    
    // 发送后等待接收动作（见下一节）
    // ...
}
```

**发送的数据格式**（文本，空格分隔）：
```
120.5 640 1.0 40.123 103.456 5000.0 100.0 50.0 -10.0 45.0 1.0 40.124 103.457 ...
```
- 第1个数字：仿真时间（秒）
- 第2个数字：状态数据长度（640，即 80平台 × 8值）
- 后面640个数字：所有平台的状态值（平台0的8个值，平台1的8个值，...）

### 1.3 Python 端：接收并解析状态

**位置**：`envs/afsim/afsim_sim.py` 的 `receive_state()` 方法

```python
def receive_state(self):
    # 1. 从 Socket 接收数据（最多 20KB）
    data = self.connection.recv(20480)
    
    # 2. 解码为字符串
    received_str = data.decode('ascii', errors='ignore').strip()
    
    # 3. 按空格分割
    tokens = received_str.split()
    # tokens = ["120.5", "640", "1.0", "40.123", "103.456", ...]
    
    # 4. 解析时间
    sim_time = float(tokens[0])  # 120.5
    
    # 5. 解析数据长度
    state_len = int(tokens[1])   # 640
    
    # 6. 解析状态值（从 tokens[2] 开始，共 640 个）
    state_array = []
    for i in range(2, 2 + state_len):
        state_array.append(float(tokens[i]))
    
    # 7. 转换为结构化字典
    # state_array 是扁平数组：[live_0, lat_0, lon_0, ..., live_1, lat_1, ...]
    # 需要按每 8 个值一组，解析为平台状态
    return self._parse_state_array(state_array, sim_time)
```

**解析后的状态字典**：
```python
{
    'platforms': {
        'platform_0': PlatformState(
            alive=True,
            lat=40.123,
            lon=103.456,
            alt=5000.0,
            vel_x=100.0,
            vel_y=50.0,
            vel_z=-10.0,
            heading=45.0
        ),
        'platform_1': PlatformState(...),
        ...
    },
    'sim_time': 120.5,
    'red_alive': 5,
    'blue_alive': 3
}
```

---

## 二、动作是怎么发送的（Python → AFSIM）

### 2.1 Python 端：准备动作数据

**位置**：`envs/afsim/afsim_sim.py` 的 `send_actions()` 方法

假设神经网络为每个智能体生成了 8 维动作向量：
```python
actions = {
    'red_fighter_0': [0.5, -0.3, 0.2, 0.8, 0.0, 0.6, 0.1, 0.0],  # 8维动作
    'red_fighter_1': [0.2, 0.1, -0.1, 0.0, 0.0, 0.0, 0.0, 0.0],
    'red_sam_0': [0.0, 0.0, 0.0, 0.9, 0.0, 0.7, 0.0, 0.0],
    ...
}
```

### 2.2 Python 端：映射到平台索引并打包

```python
def send_actions(self, actions):
    # 1. 创建大数组：80 平台 × 8 动作值 = 640 个浮点数
    action_array = [0.0] * 640
    
    # 2. 遍历每个智能体的动作
    for agent_id, action in actions.items():
        # 解析智能体 ID，获取平台索引
        # 例如：'red_fighter_0' → platform_idx = 0
        #      'red_sam_0' → platform_idx = 3
        #      'red_tank_0' → platform_idx = 6
        
        if agent_id == 'red_fighter_0':
            platform_idx = 0
        elif agent_id == 'red_fighter_1':
            platform_idx = 1
        elif agent_id == 'red_sam_0':
            platform_idx = 3
        # ... 其他映射
        
        # 3. 将动作值放入对应位置
        offset = platform_idx * 8  # 每个平台占 8 个位置
        for j in range(8):
            action_array[offset + j] = float(action[j])
    
    # 4. 发送 "STATUS" 前缀（7 字节）
    prefix = "STATUS".encode('utf-8')
    self.connection.send(prefix)
    
    # 5. 发送二进制动作数据（640 个 float，共 2560 字节）
    action_bytes = struct.pack('640f', *action_array)
    self.connection.send(action_bytes)
```

**平台索引映射规则**：
- `red_fighter_0/1/2` → 平台索引 0/1/2
- `red_sam_0/1` → 平台索引 3/4
- `red_radar_0` → 平台索引 5
- `red_tank_0/1/2` → 平台索引 6/7/8

**发送的数据格式**：
```
"STATUS" (7字节文本) + 640个float (2560字节二进制)
```

### 2.3 AFSIM 端：C++ 接收动作数据

**位置**：`WsfStandardApplication.cpp`

```cpp
// 在仿真循环中，发送完状态后等待接收动作
char prefix[7];
aSocket->Receive(prefix, 6, 0.1);  // 先接收前缀

if (strcmp(prefix, "STATUS") == 0) {
    // 接收动作数据（二进制）
    char recieve_info[10000];
    int val_read = aSocket->Receive(recieve_info, sizeof(recieve_info) - 1, 0.1);
    
    // 解析为 float 数组
    int receive_size = val_read / sizeof(float);  // 应该是 640
    std::vector<float> receive_nums(receive_size);
    memcpy(receive_nums.data(), recieve_info, receive_size * sizeof(float));
    
    // 写入 SACProcessor 的状态数组（复用存储动作）
    if (receive_size == 640) {
        for (int i = 0; i < 80; i++) {
            for (int j = 0; j < 8; j++) {
                // 将动作值存入 states[i][j]
                // 注意：虽然叫 states，但这里存的是动作指令
                sac_processor->states[i][j] = receive_nums[8 * i + j];
            }
        }
    }
    
    // 设置 flag = 2，通知脚本层有新的动作需要执行
    sac_processor->flag = 2;
}
```

**关键点**：
- C++ 端将接收到的动作数据写入 `SACProcessor::states[i][j]`
- 虽然数组名叫 "states"，但此时存储的是动作指令
- 设置 `flag = 2` 通知脚本层处理动作

---

## 三、每个动作是怎么执行的（AFSIM 脚本层）

### 3.1 脚本检测到新动作

**位置**：`state_observer.txt` 的 `UpdateStates()` 函数

```cpp
// 每 0.5 秒执行一次
if (sacprocessor.GetFlag() == 2) {
    // flag == 2 表示有新的动作数据需要执行
    
    // 只对红方平台（索引 0-8）执行动作
    for (int i = 0; i < 9; i++) {
        WsfPlatform platform = WsfSimulation.FindPlatform(platform_names.Get(i));
        
        // 从 SACProcessor 读取动作值
        // 注意：动作值存储在状态数组的对应位置
        double turnCmd = sacprocessor.GetLat(i);   // 动作[0] → 转向
        double altCmd  = sacprocessor.GetLon(i);   // 动作[1] → 高度
        double spdCmd  = sacprocessor.GetAlt(i);    // 动作[2] → 速度
        double fireCmd = sacprocessor.GetVelx(i);   // 动作[3] → 开火
        double highgCmd = sacprocessor.GetVely(i); // 动作[4] → 高G规避
        double atkCmd = sacprocessor.GetVelz(i);   // 动作[5] → 攻击姿态
        double abCmd = sacprocessor.GetHeading(i); // 动作[6] → 加力
        
        // 根据平台类型执行不同动作（见下面详细说明）
        ...
    }
    
    // 动作执行完毕，清空动作数组
    for (int i = 0; i < 9; i++) {
        sacprocessor.SetLat(i, 0.0);
        sacprocessor.SetLon(i, 0.0);
        sacprocessor.SetAlt(i, 0.0);
        // ... 清空所有动作值
    }
    sacprocessor.SetFlag(0);  // 重置标志位
}
```

### 3.2 战斗机（索引 0-2）的动作执行

```cpp
if (i <= 2) {  // 战斗机
    // 动作[0]：转向控制
    // turnCmd 范围 [-1, 1]，转换为航向角变化
    double newHdg = platform.Heading() + turnCmd * 45.0;
    // 例如：turnCmd = 0.5 → 航向角增加 22.5 度
    platform.TurnToHeading(newHdg);
    
    // 动作[1]：高度控制
    // altCmd 范围 [-1, 1]，转换为高度变化（±2000米）
    double altTarget = platform.Altitude() + altCmd * 2000.0;
    // 例如：altCmd = -0.3 → 高度降低 600 米
    platform.GoToAltitude(altTarget, 50.0);  // 50.0 是爬升率限制
    
    // 动作[2]：速度控制
    // spdCmd 范围 [-1, 1]，转换为速度变化（±150 m/s）
    // abCmd（动作[6]）：加力，额外速度偏置（±200 m/s）
    double spdTarget = platform.Speed() + spdCmd * 150.0 + abCmd * 200.0;
    // 限制速度范围 [120, 650] m/s
    if (spdTarget < 120.0) spdTarget = 120.0;
    if (spdTarget > 650.0) spdTarget = 650.0;
    platform.GoToSpeed(spdTarget);
    
    // 动作[4]：高G 规避（>0.5 触发）
    if (highgCmd > 0.5) {
        // 紧急转向 90 度，加速
        double breakHdg = platform.Heading() + 90.0;
        platform.TurnToHeading(breakHdg);
        platform.GoToSpeed(platform.Speed() + 80.0);
    }
    
    // 动作[5]：攻击姿态（>0.5 触发）
    if (atkCmd > 0.5) {
        // 寻找最近敌机
        WsfLocalTrackList tracks = platform.MasterTrackList();
        WsfTrack bestTarget = FindNearestEnemy(platform, tracks);
        
        if (bestTarget.IsValid()) {
            // 计算敌机相对方位角
            double az = platform.RelativeAzimuthOf(bestTarget.ReportedLocation());
            // 转向对准敌机
            double tgtHdg = platform.Heading() + az;
            platform.TurnToHeading(tgtHdg);
        }
    }
    
    // 动作[3]：开火（>0.5 触发）
    if (fireCmd > 0.5) {
        // 寻找最近敌机
        WsfTrack bestTarget = FindNearestEnemy(platform, tracks);
        
        if (bestTarget.IsValid()) {
            // 获取导弹武器
            WsfWeapon wpn = platform.Weapon("aam_missile");
            if (wpn.IsValid() && wpn.QuantityRemaining() > 0) {
                // 发射导弹
                wpn.Fire(bestTarget);
            }
        }
    }
}
```

**战斗机动作映射表**：

| 动作索引 | 动作值范围 | 含义 | 执行方式 |
|---------|----------|------|---------|
| action[0] | [-1, 1] | 转向 | `TurnToHeading(当前航向 + 动作值 × 45°)` |
| action[1] | [-1, 1] | 高度 | `GoToAltitude(当前高度 + 动作值 × 2000米)` |
| action[2] | [-1, 1] | 速度 | `GoToSpeed(当前速度 + 动作值 × 150 m/s)` |
| action[3] | [0, 1] | 开火 | 如果 > 0.5，发射导弹攻击最近敌机 |
| action[4] | [0, 1] | 高G规避 | 如果 > 0.5，紧急转向 90° 并加速 |
| action[5] | [0, 1] | 攻击姿态 | 如果 > 0.5，转向对准最近敌机 |
| action[6] | [-1, 1] | 加力 | 速度额外偏置（±200 m/s） |
| action[7] | - | 保留 | 未使用 |

### 3.3 SAM（索引 3-4）的动作执行

```cpp
else if (i <= 4) {  // SAM（地对空导弹）
    // SAM 主要执行开火动作
    
    // 动作[3]：开火（>0.5 触发）
    // 动作[5]：发射许可（>0.2 触发）
    if (fireCmd > 0.5 && atkCmd > 0.2) {
        // 寻找最佳目标（考虑高度、距离）
        WsfLocalTrackList tracks = platform.MasterTrackList();
        WsfTrack bestTarget = FindBestSAMTarget(platform, tracks);
        // 筛选条件：
        // - 敌方目标
        // - 高度 > 100 米（空中目标）
        // - 距离在 4000-75000 米范围内
        
        if (bestTarget.IsValid()) {
            WsfWeapon wpn = platform.Weapon("sam");
            if (wpn.IsValid() && wpn.QuantityRemaining() > 0) {
                wpn.Fire(bestTarget);  // 发射 SAM 导弹
            }
        }
    }
    
    // SAM 不执行移动动作（地面固定平台）
}
```

**SAM 动作映射表**：

| 动作索引 | 含义 | 执行方式 |
|---------|------|---------|
| action[3] | 开火 | 如果 > 0.5 且 action[5] > 0.2，发射 SAM |
| action[5] | 发射许可 | 开火的必要条件 |
| 其他 | - | 未使用 |

### 3.4 坦克（索引 6-8）的动作执行

```cpp
else {  // 坦克（地面单位）
    // 动作[0]：转向控制
    double newHdg = platform.Heading() + turnCmd * 30.0;
    // 转向幅度较小（±30°），因为地面单位转向慢
    platform.TurnToHeading(newHdg);
    
    // 动作[2]：速度控制
    double spdTarget = platform.Speed() + spdCmd * 10.0;
    // 速度变化较小（±10 m/s），因为坦克速度慢
    if (spdTarget < 0.0) spdTarget = 0.0;
    if (spdTarget > 15.0) spdTarget = 15.0;  // 限制最大速度
    platform.GoToSpeed(spdTarget);
    
    // 动作[5]：激进接近（>0.5 触发）
    if (atkCmd > 0.5) {
        // 寻找最近地面敌目标
        WsfTrack bestTarget = FindNearestGroundEnemy(platform, tracks);
        // 筛选条件：敌方、高度 < 200 米（地面目标）
        
        if (bestTarget.IsValid()) {
            // 转向对准目标
            double az = platform.RelativeAzimuthOf(bestTarget.ReportedLocation());
            double tgtHdg = platform.Heading() + az;
            platform.TurnToHeading(tgtHdg);
        }
    }
    
    // 动作[3]：开火（>0.5 触发）
    if (fireCmd > 0.5) {
        WsfTrack bestTarget = FindNearestGroundEnemy(platform, tracks);
        if (bestTarget.IsValid()) {
            WsfWeapon wpn = platform.Weapon("main_gun");
            if (wpn.IsValid() && wpn.QuantityRemaining() > 0) {
                wpn.Fire(bestTarget);  // 发射主炮
            }
        }
    }
}
```

**坦克动作映射表**：

| 动作索引 | 含义 | 执行方式 |
|---------|------|---------|
| action[0] | 转向 | `TurnToHeading(当前航向 + 动作值 × 30°)` |
| action[2] | 速度 | `GoToSpeed(当前速度 + 动作值 × 10 m/s)`，限制 [0, 15] |
| action[3] | 开火 | 如果 > 0.5，发射主炮攻击最近地面敌目标 |
| action[5] | 激进接近 | 如果 > 0.5，转向对准最近地面敌目标 |
| 其他 | - | 未使用 |

### 3.5 AFSIM 仿真引擎执行

当脚本调用 `platform.TurnToHeading()`、`platform.GoToSpeed()` 等方法后：

1. **物理仿真更新**：
   - 航向角、速度、高度按物理规律逐步变化
   - 考虑加速度限制、转弯半径等约束

2. **武器系统**：
   - `wpn.Fire(target)` 发射导弹/炮弹
   - 计算弹道、碰撞检测、毁伤判定

3. **可视化更新**：
   - 在 AFSIM 3D 视图中实时显示平台位置、航向、速度
   - 显示武器发射轨迹、爆炸效果

---

## 四、完整交互流程示例

假设当前时刻，Python 端要发送动作给 `red_fighter_0`：

### 步骤 1：Python 生成动作
```python
action = [0.5, -0.3, 0.2, 0.8, 0.0, 0.6, 0.1, 0.0]
# 含义：转向0.5，降低高度0.3，加速0.2，开火0.8，攻击姿态0.6
```

### 步骤 2：Python 发送
```python
# 映射到平台索引 0
action_array[0:8] = [0.5, -0.3, 0.2, 0.8, 0.0, 0.6, 0.1, 0.0]
# 发送 "STATUS" + 640个float
```

### 步骤 3：AFSIM C++ 接收
```cpp
// 接收数据，写入 SACProcessor
sac_processor->states[0][0] = 0.5;   // turnCmd
sac_processor->states[0][1] = -0.3;  // altCmd
sac_processor->states[0][2] = 0.2;   // spdCmd
sac_processor->states[0][3] = 0.8;   // fireCmd
sac_processor->states[0][4] = 0.0;   // highgCmd
sac_processor->states[0][5] = 0.6;   // atkCmd
sac_processor->states[0][6] = 0.1;   // abCmd
sac_processor->flag = 2;
```

### 步骤 4：AFSIM 脚本执行
```cpp
// 读取动作值
turnCmd = 0.5;   // 转向
altCmd = -0.3;   // 降低高度
spdCmd = 0.2;    // 加速
fireCmd = 0.8;   // 开火
atkCmd = 0.6;    // 攻击姿态

// 执行动作
platform.TurnToHeading(当前航向 + 0.5 * 45°);  // 转向 22.5°
platform.GoToAltitude(当前高度 - 0.3 * 2000米); // 降低 600 米
platform.GoToSpeed(当前速度 + 0.2 * 150 + 0.1 * 200); // 加速
if (atkCmd > 0.5) {
    转向对准最近敌机;
}
if (fireCmd > 0.5) {
    发射导弹攻击最近敌机;
}
```

### 步骤 5：AFSIM 仿真执行
- 平台在 3D 视图中转向、下降、加速
- 导弹发射，追踪目标
- 状态更新，准备下一轮发送

---

## 五、关键数据格式总结

### 状态数据（AFSIM → Python）
- **格式**：文本，空格分隔
- **内容**：`时间 长度 值1 值2 ... 值640`
- **示例**：`120.5 640 1.0 40.123 103.456 5000.0 100.0 50.0 -10.0 45.0 ...`

### 动作数据（Python → AFSIM）
- **格式**：`"STATUS"` (7字节文本) + 640个float (2560字节二进制)
- **内容**：80 平台 × 8 动作值 = 640 个浮点数
- **范围**：每个动作值通常在 [-1, 1] 范围内

### 标志位说明
- `flag = 0`：空闲，等待动作
- `flag = 1`：状态就绪，C++ 发送状态给 Python
- `flag = 2`：动作就绪，脚本执行动作

---

**文档版本**：v2.0（简化版）  
**最后更新**：2024年

