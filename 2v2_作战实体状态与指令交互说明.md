# 2v2（P6DOF）作战实体状态与指令交互说明（AFSIM ↔ Python）

本说明文档用于解释 `build/demos/air_to_air/2v2.txt` 场景中，**AFSIM 与 Python 之间**如何进行：

- **状态回传**（AFSIM → Python）
- **控制指令回传**（Python → AFSIM）
- **指令在 AFSIM 内部的执行方式**（P6DOF 控制：转向/爬升下降/加减速）

整体结构参考 `动作与状态交互说明.md`，但内容以本工程当前实现为准。

---

## 一、总体闭环与关键文件

### 1.1 闭环（Flag 驱动）

本工程采用 **SACProcessor + flag** 的三态握手：

- **flag = 0**：空闲（允许脚本采样状态）
- **flag = 1**：状态已写入 SACProcessor，等待 C++/Warlock 发送给 Python
- **flag = 2**：动作已从 Python 收到并写入 SACProcessor，等待脚本层执行动作

### 1.2 关键文件与职责

- **场景入口**：`build/demos/air_to_air/2v2.txt`
  - 选择 `SCNRIO = 2v2_p6dof`
  - `include_once StatesObserver.txt`（周期采样并置 `flag=1`）
- **P6DOF 场景与动作执行**：`build/demos/air_to_air/scenarios/2v2_p6dof.txt`
  - `flag==2` 时读取动作并调用平台控制接口（P6DOF）
- **状态采样脚本**：`build/demos/air_to_air/StatesObserver.txt`
  - 每 0.5 秒采样平台状态并写入 SACProcessor（`flag==0` 才采样），然后置 `flag=1`
- **C++ 收发（TCP）**：`swdev/src/core/wsf/source/WsfStandardApplication.cpp`
  - 在仿真循环中检测 `flag==1` → 发送状态 → 接收动作 → 写回 `SACProcessor::states` 并置 `flag=2`
- **Python 控制端**：`llm-llm_with_connection.py`
  - 作为 TCP Server（`localhost:65432`）接收状态、快速回包动作、后台慢推理更新动作

> 重要：本工程的 TCP 回路由 **Warlock 进程**建立连接（C++ 中固定连接 `127.0.0.1:65432`）。因此运行时通常使用 `warlock.exe`，Python 必须先启动并监听端口。

---

## 二、状态是怎么传送的（AFSIM → Python）

### 2.1 脚本层：周期采样平台状态（写入 SACProcessor）

**位置**：`build/demos/air_to_air/StatesObserver.txt`

**触发方式**：`execute at_interval_of 0.5 sec`

**触发条件**：仅当 `sacprocessor.GetFlag() == 0`（空闲）时采样并发送。

**写入内容**：每个平台 8 个值写入 `SACProcessor::states[id][0..7]`：

1. `live`（0/1）
2. `lat`（纬度）
3. `lon`（经度）
4. `alt`（米）
5. `velN`（北向速度，m/s）
6. `velE`（东向速度，m/s）
7. `velD`（下向速度，m/s）
8. `heading`（航向角，度）

采样完成后置 `flag=1`，通知 C++/Warlock 发送。

### 2.2 C++/Warlock：发送状态文本帧

**位置**：`swdev/src/core/wsf/source/WsfStandardApplication.cpp`（socket 版本的 `RunEventLoop`）

当检测到 `sac_processor->flag == 1`：

- 组装一段**文本**（空格分隔）
- 发送到 Python（TCP）

**发送帧格式**：

```
simTime 640 v0 v1 v2 ... v639 
```

- 第 1 个字段：仿真时间 `simTime`
- 第 2 个字段：固定为 `640`（= 80 平台 × 8 值）
- 后面 640 个字段：`states[0][0..7], states[1][0..7], ..., states[79][0..7]`

> 注意：这是一段文本流，TCP 可能会出现半包/粘包，所以 Python 端必须做缓冲按 token 凑齐一帧再解析（见 `StateReceiver`）。

---

## 三、指令是怎么传回的（Python → AFSIM）

### 3.1 Python：动作数组（640 float32）与发送格式

**位置**：`llm-llm_with_connection.py`

Python 回传的数据为：

1. 6 字节前缀：`STATUS`
2. 2560 字节动作负载：`640 * float32`（小端）

即：

```
"STATUS" + <640 float32 binary>
```

### 3.2 动作字段含义（仅使用前三个通道）

在当前 `2v2_p6dof` 场景里，每个平台 8 维动作仅使用前 3 个：

- `a0`：相对航向变化（归一化，建议 [-1, 1]）
- `a1`：相对高度变化（归一化，建议 [-1, 1]）
- `a2`：相对速度变化（归一化，建议 [-1, 1]）
- `a3..a7`：保留（当前不使用）

### 3.3 平台索引映射（与脚本一致）

当前场景 `build/demos/air_to_air/scenarios/2v2_p6dof.txt` 约定前 4 个索引对应：

- idx 0 → `red_1`
- idx 1 → `red_2`
- idx 2 → `blue_1`
- idx 3 → `blue_2`

其余 idx 4..79 保持 0。

> 如果只控制红方两架，Python 只需要填充 idx0/idx1 的动作，其余保持 0。

---

## 四、指令在 AFSIM 中如何落地执行（P6DOF 控制）

### 4.1 C++/Warlock：接收动作并写回 SACProcessor

**位置**：`swdev/src/core/wsf/source/WsfStandardApplication.cpp`

发送完状态后，C++ 会等待接收 6 字节前缀：

- 若前缀为 `STATUS`：
  - 再接收一段二进制数据
  - 解析为 float 数组（期望 640 个）
  - 写入 `sac_processor->states[i][j] = receive_nums[8*i + j]`
  - 置 `sac_processor->flag = 2`，通知脚本层执行动作

> 关键点：此时 `states[][]` 这个数组“复用”为动作缓存（名字叫 states，但 flag==2 时存的是动作）。

### 4.2 脚本层：读取动作并调用 P6DOF 控制接口

**位置**：`build/demos/air_to_air/scenarios/2v2_p6dof.txt`

当 `sacprocessor.GetFlag() == 2` 时，对每个受控平台执行：

1. **读取动作**
   - `a0 = sacprocessor.GetLive(i)`
   - `a1 = sacprocessor.GetLat(i)`
   - `a2 = sacprocessor.GetLon(i)`

2. **动作归一化 → 物理量（相对量 → 目标量）**
   - 航向变化：`dHdg_deg = a0 * 45.0`
   - 高度目标（米）：`tgtAlt_m = currentAlt_m + a1 * 2000.0`
   - 速度目标（m/s）：`tgtSpd_mps = currentSpd_mps + a2 * 150.0`

3. **调用平台控制方法（对 P6DOF 友好）**
   - 转向：`platform.TurnToRelativeHeading(dHdg_deg, 0.5 * 9.8)`
   - 高度：`platform.GoToAltitude(tgtAlt_m, 50.0)`
   - 速度：`platform.GoToSpeed(tgtSpd_mps)`

4. **清 flag**
   - 仅在消费完动作（flag==2）后执行 `sacprocessor.SetFlag(0)`，回到空闲状态，允许下一轮状态采样发送。

### 4.3 P6DOF Mover 控制说明（为什么能用）

`2v2_p6dof` 场景使用 `FA-LGT`（P6DOF 平台类型），其 mover 为 `WSF_P6DOF_MOVER`。

脚本层调用的 `WsfPlatform` 方法（`TurnToRelativeHeading/GoToAltitude/GoToSpeed`）会路由到 mover 层，并最终由 `WsfP6DOF_Mover` 执行控制律。

另外，为避免某些情况下 autopilot/controls 未使能导致命令不生效，脚本中会在执行动作前做一次保险使能：

- `p6mover.EnableAutopilot(true)`
- `p6mover.EnableControls(true)`

---

## 五、Python 端的“快回包 + 慢推理”（适配 5 秒推理）

由于 LLM 推理可能需要 ~5 秒，而 AFSIM 端收动作等待窗口较短，为保证回路稳定：

- Python 主线程：
  - 收到一帧状态后，**立刻回传上一帧动作**（初始为全 0）
  - 将最新状态放入队列（队列容量=1，只保留最新）
- 后台线程：
  - 从队列取最新状态进行 LLM 推理
  - 生成新动作并覆盖 `last_action`，供下一帧快速回包使用

这样 AFSIM 不会因为等待 5 秒而卡住，控制仍能以“延迟更新”的方式生效。

---

## 六、运行方式建议（Warlock + Python）

1. 先启动 Python（在 conda 的 `wow` 环境）：

```powershell
conda run -n wow python -u .\llm-llm_with_connection.py
```

2. 再启动 Warlock 并运行：

- `build/demos/air_to_air/2v2.txt`（内部会加载 `2v2_p6dof`、`StatesObserver` 等）

---

## 七、常见问题与排查要点

### 7.1 “Unknown identifier: SACProcessor”

说明 `SAC_processor.dll` 未被加载，需确保插件在 Warlock 的插件搜索路径下（通常为 `bin/wsf_plugins/` 或 `bin/mission_plugins/` 之一，且不要重复放置导致 duplicate）。

### 7.2 “Duplicate extension: SAC_processor”

说明同一插件被加载两次（例如同时放在 `bin/wsf_plugins/` 与 `bin/mission_plugins/`）。只保留一份即可。

### 7.3 Python 一直没有 “已连接”

Warlock 只有在仿真开始执行时才会连接 `127.0.0.1:65432`。请确认：

- Python 已先启动并监听
- Warlock 已开始运行仿真（不是仅打开场景）


